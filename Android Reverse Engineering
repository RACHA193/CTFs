ANDROID REVERSE ENGINEERING – (Flag Challenge)

---------------------------------------------------------------------------------------------------------------------------------------------------------------
This repository summarizes my approach to solving a static + dynamic Android reverse engineering challenge as part of the interview process. 
The goal was to extract a hidden flag embedded in an APK.


OBJECTIVE:

Analyze an Android APK where the flag is encrypted inside an asset file, not visible in plain Java code. Use reverse engineering techniques to:

- Uncover the AES encryption key at runtime  
- Decrypt an embedded payload (PNG)  
- Reconstruct a valid DEX file from encrypted bytes  
- Extract the flag from the recovered bytecode


TOOLS USED:

- jadx for static code decompilation  
- Frida for runtime instrumentation and native method hooking  
- Python for asset extraction, AES decryption, and DEX header repair  
- Rooted Android emulator for live testing  
- adb, logcat, Wireshark for auxiliary observation

---------------------------------------------------------------------------------------------------------------------------------------------------------------
Analysis Workflow:

1. Static Analysis

- Parsed 'AndroidManifest.xml' to identify entry points and components  
- Traced execution from 'MainActivity' to 'NotificationsFragment'  
- Located AES key loading and PNG asset reference ('google.png')  
- Found suspicious native method call used in decryption  
- Confirmed obfuscated class layout and byte array handling

2. Dynamic Analysis

- Wrote a custom Frida hook ('hook_fragment.js') to intercept the native 'Fragment(int)' method
- Captured runtime AES key
- Dumped and decrypted asset bytes from 'google.png' at offset
- Repaired the DEX header: recalculated Adler-32 and SHA-1 hashes  
- Loaded valid '.dex' into JADX to found cleartext flag

---------------------------------------------------------------------------------------------------------------------------------------------------------------
hook_fragment.js:

Java.perform(function() {
  var F = Java.use("com.google.ctf.ui.notifications.NotificationsFragment");
  F.Fragment.implementation = function(x) {
    var key = this.Fragment(x);
    console.log("AES key:", key);
    return key;
  };
});

---------------------------------------------------------------------------------------------------------------------------------------------------------------
extract_and_fix.py:

import zlib, hashlib, struct
from Crypto.Cipher import AES

# 1) AES key and offset
key         = b"xxxxxxxxxxxxx"
base_offset = xxxxx

# 2) Read & decrypt
with open("google.png", "rb") as f:
    f.seek(base_offset)
    encrypted = f.read()
cipher    = AES.new(key, AES.MODE_ECB)
decrypted = cipher.decrypt(encrypted)

# 3) Find the DEX magic at the start
magic = b"dex\n035\x00"
if not decrypted.startswith(magic):
    raise RuntimeError("DEX magic missing at start of decrypted data!")

# 4) Read the DEX file-size from header (bytes 32–35 little-endian)
file_size = struct.unpack("<I", decrypted[32:36])[0]

# 5) Slice out exactly file_size bytes
dex_data = decrypted[:file_size]

# 6) Recompute checksum (bytes 12 onward) and signature (bytes 32 onward)
chk = zlib.adler32(dex_data[12:]) & 0xFFFFFFFF
sig = hashlib.sha1(dex_data[32:]).digest()

fixed = bytearray(dex_data)
fixed[8:12]  = struct.pack("<I", chk)
fixed[12:32] = sig

# 7) Write the final DEX
with open("hidden.dex", "wb") as out:
    out.write(fixed)

print(f"hidden.dex written ({file_size} bytes, header fixed)")

---------------------------------------------------------------------------------------------------------------------------------------------------------------
Key Takeaways:

- How to analyze APKs with heavy obfuscation and custom decryption logic  
- Dynamic analysis is often essential when reversing native-layer secrets  
- DEX header repair and byte-level forensics can be critical to extracting embedded payloads  
- Combining static, dynamic, and scripting workflows makes reversing efficient and scalable

---------------------------------------------------------------------------------------------------------------------------------------------------------------
Disclaimer:

No original APK files, decompiled code, or sensitive challenge content is shared publicly. 
This repo only describes methodology and tooling to showcase reverse engineering workflows.


